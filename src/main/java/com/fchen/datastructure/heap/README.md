### 堆
&ensp;&ensp;1. **(二叉)堆** 是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个几点都对应数组中的一个元素。除了最底层外，该树是完全满的，而且是从左向右填充。

&ensp;&ensp;2. 表示堆的数组A包括两个属性：A.length 给出数组元素的个数，A.heap-size 表示有多少个堆元素存储在该数组中。

&ensp;&ensp;3. 当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为**堆有序**。

&ensp;&ensp;4. **二叉堆**是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储。
#### 1 性质
1.1 给定一个节点的下标**i**:
* 1.1.1 若 树的根节点在数组中 用**A[1]** 表示:

      父亲节点下标：RARENT(i) = i / 2; 
      左孩子节点的下标: LEFT(i) = 2 * i;
      右孩子几点的下标：RIGHT(i) = 2 * i + 1;
* 1.1.2 若 树的根节点在数组中 用**A[0]** 表示:   
 
      父亲节点下标：PARENT(i) = (i - 1) / 2;
      左孩子节点的下标: LEFT(i) = 2 * i + 1;
      右孩子几点的下标：RIGHT(i) = 2 * i + 2; 
1.2 对于一个包含N个元素的堆，它的高度是log N
 
1.3 堆中某个节点的值总不大于或不小于其父节点的值
* 1.3.1 最大堆
    1. 首先节点满足堆的性质
    2. A[PARENT(i)] ≥ A[i] 除了根节点以外的所有节点i都满足。（最大元素在根节点）

* 1.3.2 最小堆
    1. 首先节点满足堆的性质
    2. A[PARENT(i)] ≤ A[i] 除了根节点以外的所有节点i都满足。（最小元素在根节点）
    
#### 2 堆的有序化
&ensp;&ensp;堆中的元素操作(增加、修改、删除)会打破(二叉)堆的状态，然后再遍历堆并按照要求将堆的状态恢复。这个过程叫做--堆的有序化。

##### 2.1  上浮(由下至上的堆有序化)
&ensp;&ensp;如果堆的有序状态因为某个节点编的比父节点更大而打破，我们就需要通过交换它和它的父节点来维护堆的状态。
交换后，这个节点比他的两个子节点都大，但是这个节点仍然可能小于他的父节点，充度上述操作，知道满足堆的要求。

_上浮示意图_

伪代码:(这里以堆的根节保存在数组索引为0的位置为例)
```
//当前节点对应 数组下标 为 k
siftUp(k):
   while(k > 0 && A[k] > A[PARENT(k)]){
       temp = A[PARENT(k)];
       A[PARENT(k)] = A[k];
       A[k] = tesmp;
       k = PARENT[k]
   }
```
对应代码实现部分:MaxHeap.java 中的 siftUp(int k); 方法
##### 2.2  下沉(由上至下的堆有序化)
&ensp;&ensp;如果堆的有序状态因为某个节点变地比他的子节点更小，那么我们就需要将它和它的两个子节点中较大的节点交换来维护堆的状态。

_下沉示意图_

伪代码:(这里以堆的根节保存在数组索引为0的位置为例)
```
//当前节点对应 数组下标 为 k,数组中元素的个数为N
siftDown(k):
    //判断当前节点是否存在子节点
    while(LEFT(k) <= N){
        //获取子节点所在 数组下标
        int j = LEFT(k);
        //左子节点 小于 元素个数 并且 右子节点的值 大于 左子节点的值
        if(j < N  && A[j + 1] > A[j]){
            //获取右子节点所在的数组下表
            j = RIGHT(k);
        }
        // 左、右子节点交大的与父节点比较
        if(A[j] >= A[k]){
           // 交换父子节点的值
           temp = A[k];
           A[k] = A[j];
           A[j] = temp;
           k = j;
        }
    }
```
对应代码实现部分:MaxHeap.java 中的 siftDown(int k); 方法
#### 3 堆的操作
##### 3.1  插入元素
&ensp;&ensp;将元素追加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置
##### 3.2  删除最大元素
&ensp;&ensp;从数组顶端删除最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。

 
