 ## 栈的应用
 #### 1. 平衡符号
&ensp;&ensp;编译器检查程序语法的错误，但是常常由于缺少一个符号引起编译器列出上百行诊断错误，而真正的错误并没有找出。
 
&ensp;&ensp;在这种情况下，一个有用的工具就是检验是否每件事情都是成对的程序。于是，每一个右花括号、右方括号及右圆括号必然对应其相应的左括号。
  
&ensp;&ensp;这个简单的应用就用到栈:
        
    做一个空栈。读入字符知道文件结尾。如果一个字符是一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则当栈为空时报错。否则，将栈元素弹出。
    如果弹出的符号不是对应的开放符号，则报错。在文件结尾，如果栈非空则报错。 
 
 #### 2. 后缀表达式
 &ensp;&ensp;例如: 要计算 A * B + C + D * E = ? 这样的计算式的值。我们可以将A和B相乘的值存为A1，然后将C和A1相加，在将结果存入A1；我们在将D和E相乘
 的值存为A2，最后将A1和A2相加并将最后结果放入A1。我们可以将这种操作顺序书写如下：
    
    A B * C + D E * +
  &ensp;&ensp;这个记法叫做**后缀**或**逆波兰**记法，其求值过程就是上面所描述的过程。计算这个问题最容易的方法是使用一个栈。当见到一个数时就把它推入栈中；
  在遇到一个运算符就作用于该栈弹出的两个数上，再将所得结果推入栈中。    
 
 #### 3. 中缀和后缀的转换
 **转换步骤**：
 
 1) 初始化两个栈，运算符栈和存储中间结果的栈；
 
 2) 从左到右扫描中缀表达式；
 
 3) 遇到操作数时，将其压入结果栈；
 
 4) 遇到运算符时，比较其与运算符栈顶元素的优先级：
    
     a. 如果运算符的栈为空，或者栈顶运算符为左括号“(”,则直接将此运算符入栈；
    
     b. 否则，若优先级比栈顶运算符高，也将运算符压入运算符栈；
    
     c. 否则，将运算符栈顶运算符弹出并压入到中间结果栈中；然后再转到a与运算符中新的栈顶运算符比较。  
     
 5) 遇到括号时：
 
     a. 如果是左括号"(",则直接压入运算符栈
     
     b. 如果是右括号")",则依次弹出运算符栈栈顶的元素，并压入中间结果栈，直到遇到左括号为止，此时将这一对括号丢弃。
 
 6) 重复步骤2至5，直到表达式的最右边；
 
 7) 将运算符栈中剩余的运算符依次弹出并压入中间结果栈；
 
 8) 依次弹出中间结果栈中的元素并输出，结果的逆序就是中缀表达式对应的后缀表达式。 
 
 假设中缀表达式 a + b * c + (d * e +f) * g 转换为后缀表达式：a b c * + d e * f + g * +。
 
 
  <div align="center">
     <img src="https://github.com/FunCheney/data-structure/blob/master/src/main/java/com/fchen/datastructure/stack/image/infixTopostfix.gif">
  </div>
  
 #### 4. 前缀表达式(波兰表达式)
 **前缀表达式的计算机求值**
 &ensp;&ensp;从右至左扫描表达式，遇到数字时，将数字压入栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；
 重复上述过程直到表达式最左端，最后运算的结果就是表达式的值。
 
 前缀表达式：
     
     + * - / A B C D E
 对应中缀表达式:
 
     A / B - C * D + E
 
 
 #### 4. 方法调用

